# 分布式相关算法

## 一.分布式协调与同步
### 1.互斥(Distributed Mutual Exclusion):
在分布式系统中, 多个节点共享临界资源(如全局配置文件)或者同时执行某个函数等, 就产生互斥问题.
一般来说, 分布式互斥算法要实现以下目标特性:
- 安全性: 即任何时刻只能有一个进程访问共享资源, 即持有互斥锁.
- 公平性: 有些场景需要尽量保证访问共享资源的公平性，这表明：系统不能出现死锁，任何进程持有锁的时间是有限的，任何等待的进程最终都能获取锁，以及等待获取锁的进程的等待时间是有限的.
- 低带宽: 尽量减少消息传输量.
- 低延迟: 尽量减少进程进入临界区之前的等待的时间.
- 动态性: 允许进程在任何时刻加入到访问共享资源的进程集合中，或者从其中退出.
- 容忍进程失败: 允许访问共享资源的进程集合中的进程因失败而退出，而保证整个系统不受影响
- 容忍消息丢失: 在消息不能按时到达、乱序甚至丢失的情况下，整个系统依然正常工作

#### 集中式算法(centralized algorithm):
- 主要思想: 引入一个协调者(coordinator)负责处理临界资源的请求. 每个程序(进程, 线程)需要访问临界资源前, 先给coordinator发送请求, 若当前临界资源没有被任何程序使用, 直接授权程序访问.否则, 针对请求顺序放入一个队列中等待.若持有临界资源的程序使用完, 则通知coordinator, coordinator从等待队列中取出一个请求, 并给它发送授权消息使其可以直接使用临界资源.
- 优点: 简单,易于实现
- 缺点: 依赖coordinator, 可用性低, 性能容易受coordinator影响
- 典型应用: 利用分布式锁去实现一个client-server


#### 分布式算法(distributed algorithm):

##### 1.使用组播和逻辑时钟(Ricart Agrawala) 
- 主要思想: Ricart & Agrawala算法是在1981年被提出的一个基于请求的分布式互斥算法. 当一个程序要访问临界资源时, 先向系统中的其他程序发送一条请求消息, 在接受到所有程序返回的同意消息后, 才可以访问临界资源.其中,请求消息必须需要包含时钟信息(时间戳), 请求id, 请求资源等.
- 算法流程:
    - 进程A在准备进入临界区时, 必须发送一条带时间戳的消息给其他进程.
    - 进程A收到其他所有进程的同意消息后, 可以进入临界区
    - 若存在进程B在收到进程A的请求之前, 发出了一个更早的请求(更小的时间戳), 进程B中维护一个延迟队列, 将进程A的请求消息加入队列中, 等进程B使用完临界区后, 从队列中取出发消息给进程A

- 优点: 可用性较高
- 缺点: 
    - 1. 向其他n-1个程序发送访问临界资源请求, 需要n-1次交互. 
    - 2. 需要接受其他n-1个程序的同意消息才可访问资源, n-1次交互
    - 3. 总共需要2(n - 1), 大型系统中大大增加消息量, 产生高昂的交互成本
    - 4. 一旦某个程序故障, 无法发送同意消息, 会造成其他程序均处于等待状态, 导致系统不可用
- 典型应用: 系统规模较小, 临界资源使用频度低的场景. 比如p2p的系统, hdfs的文件修改

##### 2.令牌环算法(Token Ring):
- 主要思想: 所有程序(进程)在逻辑上构成一个环形结构, 将token在环上按照一定的顺序传递, 拿到token的程序可以访问临界资源, 如果拿到token的程序不需要访问临界资源, 则直接传递给下一个程序.
- 优点: 
    - 公平性好, 在一个周期内每个程序都能访问到临界资源
    - 通信效率较好, 不需要通知其他所有程序.
- 缺点: 当参与者多, 并且对临界资源使用频度低时, 会产生较多的无效通信
- 典型应用: 无人机通信
